diff --git a/WICED/network/LwIP/WWD/wwd_buffer.c b/WICED/network/LwIP/WWD/wwd_buffer.c
index 296493a..05a8d24 100644
--- a/WICED/network/LwIP/WWD/wwd_buffer.c
+++ b/WICED/network/LwIP/WWD/wwd_buffer.c
@@ -29,9 +29,6 @@ wwd_result_t wwd_buffer_init( /*@null@*/ /*@unused@*/ void * native_arg )
 
 wwd_result_t host_buffer_check_leaked( void )
 {
-    wiced_assert( "pbuf TX pool Buffer leakage", memp_in_use( MEMP_PBUF_POOL_TX ) == 0 );
-    wiced_assert( "pbuf RX pool Buffer leakage", memp_in_use( MEMP_PBUF_POOL_RX ) == 0 );
-    wiced_assert( "pbuf ref/rom Buffer leakage", memp_in_use( MEMP_PBUF ) == 0 );
     return WWD_SUCCESS;
 }
 
@@ -53,7 +50,7 @@ wwd_result_t internal_host_buffer_get( wiced_buffer_t * buffer, wwd_buffer_dir_t
 
     do
     {
-        *buffer = pbuf_alloc( PBUF_RAW, size, ( direction == WWD_NETWORK_RX ) ? PBUF_POOL_RX : PBUF_POOL_TX );
+        *buffer = pbuf_alloc( PBUF_RAW, size, PBUF_POOL);
         if ( *buffer != NULL )
         {
             break;
@@ -137,15 +134,3 @@ wwd_result_t host_buffer_set_size( /*@temp@*/ wiced_buffer_t buffer, unsigned sh
          return WWD_SUCCESS;
 }
 
-
-void memp_free_notify( unsigned int type )
-{
-    if ( type == MEMP_PBUF_POOL_TX )
-    {
-        host_platform_bus_buffer_freed( WWD_NETWORK_TX );
-    }
-    else if ( type == MEMP_PBUF_POOL_RX )
-    {
-        host_platform_bus_buffer_freed( WWD_NETWORK_RX );
-    }
-}
diff --git a/WICED/network/LwIP/WWD/wwd_network.c b/WICED/network/LwIP/WWD/wwd_network.c
index 4fa4593..d83b1ec 100644
--- a/WICED/network/LwIP/WWD/wwd_network.c
+++ b/WICED/network/LwIP/WWD/wwd_network.c
@@ -17,7 +17,9 @@
 #include "lwip/debug.h"
 #include "lwip/netif.h"
 #include "lwip/igmp.h"
+#include "lwip/ethip6.h"
 #include "netif/etharp.h"
+#include "lwip/mld6.h"
 
 #include "wwd_network.h"
 #include "wwd_wifi.h"
@@ -28,6 +30,7 @@
 #include "wiced_constants.h"
 #include <stdlib.h>
 
+#include "network/wwd_network_constants.h"
 #ifdef ADD_LWIP_EAPOL_SUPPORT
 #define ETHTYPE_EAPOL    0x888E
 #endif
@@ -110,6 +113,10 @@
 static err_t lwip_igmp_mac_filter( struct netif *netif, ip_addr_t *group, u8_t action );
 #endif
 
+#if LWIP_IPV6 && LWIP_IPV6_MLD
+static err_t lwip_mld_mac_filter(struct netif *netif, const ip6_addr_t *group, u8_t action);
+#endif
+
 /**
  * In this function, the hardware should be initialized.
  * Called from ethernetif_init().
@@ -125,8 +132,14 @@ static void low_level_init( /*@partial@*/ struct netif *netif )
     /* Setup the physical address of this IP instance. */
     if ( wwd_wifi_get_mac_address( (wiced_mac_t*) ( netif->hwaddr ), (wwd_interface_t) (int) netif->state ) != WWD_SUCCESS )
     {
+      /* At least for EMW3165, getting mac address for AP interface fails.
+       * Attempt again with STA interface.
+       */
+      if ( wwd_wifi_get_mac_address( (wiced_mac_t*) ( netif->hwaddr ), WWD_STA_INTERFACE ) != WWD_SUCCESS )
+      {
         WPRINT_NETWORK_DEBUG(("Couldn't get MAC address\n"));
         return;
+      }
     }
 
     /* Set Maximum Transfer Unit */
@@ -136,6 +149,13 @@ static void low_level_init( /*@partial@*/ struct netif *netif )
     netif->flags = (u8_t) ( NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP );
 
     /* Do whatever else is needed to initialize interface. */
+#if LWIP_IPV6 && LWIP_IPV6_MLD
+    netif->mld_mac_filter = lwip_mld_mac_filter;
+    ip6_addr_t ip6_allnodes_ll;
+    ip6_addr_set_allnodes_linklocal(&ip6_allnodes_ll);
+    netif->mld_mac_filter(netif, &ip6_allnodes_ll, NETIF_ADD_MAC_FILTER);
+#endif /* LWIP_IPV6 && LWIP_IPV6_MLD */
+
 #if LWIP_IGMP
     netif->flags |= NETIF_FLAG_IGMP;
     netif_set_igmp_mac_filter(netif, lwip_igmp_mac_filter);
@@ -168,7 +188,17 @@ static err_t low_level_output( struct netif *netif, /*@only@*/ struct pbuf *p )
     {
         /* Take a reference to this packet */
         pbuf_ref( p );
+#if ETH_PAD_SIZE
 
+/*
+ * Wiced layer expects that pbuf points to beginning
+ * of ethernet frame. When using a padding word for
+ * alignment we must drop it (actually the padding word
+ * overlaps with the space used by wiced link headers
+ * but LwIP never actually touches it so this is not a problem.
+ */
+        pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
+#endif
         LWIP_ASSERT( "No chained buffers", ( ( p->next == NULL ) && ( ( p->tot_len == p->len ) ) ) );
         wwd_network_send_ethernet_data( p, (wwd_interface_t) (int) netif->state );
 
@@ -204,6 +234,16 @@ void host_network_process_ethernet_data( /*@only@*/ wiced_buffer_t buffer, wwd_i
         return;
 
     /* points to packet payload, which starts with an Ethernet header */
+#if ETH_PAD_SIZE
+
+/*
+ * LwIP expects that incoming pbuf points to padding word of ethernet header.
+ * The padding word actually has data from Wiced link layer but as it
+ * is not modified by LwIP it is ok for them to overlap.
+ */
+    pbuf_header(buffer, ETH_PAD_SIZE); /* add the padding word */
+#endif
+
     ethernet_header = (struct eth_hdr *) buffer->payload;
 
     ethertype = htons( ethernet_header->type );
@@ -227,6 +267,7 @@ void host_network_process_ethernet_data( /*@only@*/ wiced_buffer_t buffer, wwd_i
     switch ( ethertype )
     {
         case WICED_ETHERTYPE_IPv4:
+        case ETHTYPE_IPV6:
         case WICED_ETHERTYPE_ARP:
 #if PPPOE_SUPPORT
         /* PPPoE packet? */
@@ -323,6 +364,9 @@ err_t ethernetif_init( /*@partial@*/ struct netif *netif )
      */
     netif->output = etharp_output;
     netif->linkoutput = low_level_output;
+#if LWIP_IPV6
+  netif->output_ip6 = ethip6_output;
+#endif
 
     /* Initialize the hardware */
     low_level_init( netif );
@@ -343,14 +387,14 @@ static err_t lwip_igmp_mac_filter( struct netif *netif, ip_addr_t *group, u8_t a
 
     switch ( action )
     {
-        case IGMP_ADD_MAC_FILTER:
+        case NETIF_ADD_MAC_FILTER:
             if ( wwd_wifi_register_multicast_address( &mac ) != WWD_SUCCESS )
             {
                 return ERR_VAL;
             }
             break;
 
-        case IGMP_DEL_MAC_FILTER:
+        case NETIF_DEL_MAC_FILTER:
             if ( wwd_wifi_unregister_multicast_address( &mac ) != WWD_SUCCESS )
             {
                 return ERR_VAL;
@@ -365,4 +409,45 @@ static err_t lwip_igmp_mac_filter( struct netif *netif, ip_addr_t *group, u8_t a
 }
 #endif
 
+#if LWIP_IPV6 && LWIP_IPV6_MLD
+static err_t lwip_mld_mac_filter(struct netif *netif, const ip6_addr_t *group, u8_t action)
+{
+  wiced_mac_t mac;
+  uint8_t* g = (uint8_t*)&group->addr[3];
+
+  mac.octet[0] = 0x33;
+  mac.octet[1] = 0x33;
+  mac.octet[2] = g[0];
+  mac.octet[3] = g[1];
+  mac.octet[4] = g[2];
+  mac.octet[5] = g[3];
+
+  /*@-noeffect@*/
+  UNUSED_PARAMETER(netif);
+  /*@+noeffect@*/
+
+  switch ( action )
+  {
+      case NETIF_ADD_MAC_FILTER:
+          if ( wwd_wifi_register_multicast_address( &mac ) != WWD_SUCCESS )
+          {
+              return ERR_VAL;
+          }
+          break;
+
+      case NETIF_DEL_MAC_FILTER:
+          if ( wwd_wifi_unregister_multicast_address( &mac ) != WWD_SUCCESS )
+          {
+              return ERR_VAL;
+          }
+          break;
+
+      default:
+          return ERR_VAL;
+  }
+
+  return ERR_OK;
+}
+#endif
+
 /********************************** End of file ******************************************/
diff --git a/platforms/EMW3165/platform_config.h b/platforms/EMW3165/platform_config.h
index 9ce21f2..fef5eb4 100644
--- a/platforms/EMW3165/platform_config.h
+++ b/platforms/EMW3165/platform_config.h
@@ -30,7 +30,7 @@ extern "C" {
 #define WICED_WIFI_USE_GPIO_FOR_BOOTSTRAP_1
  
 /*  Wi-Fi GPIO0 pin is used for out-of-band interrupt */
-#define WICED_WIFI_OOB_IRQ_GPIO_PIN  ( 0 )
+#define WICED_WIFI_OOB_IRQ_GPIO_PIN  ( 1 )
 
 /*  Wi-Fi power pin is present */
 //#define WICED_USE_WIFI_POWER_PIN
@@ -39,7 +39,7 @@ extern "C" {
 #define WICED_USE_WIFI_RESET_PIN
 
 /* */
-#define WICED_USE_WIFI_32K_CLOCK_MCO
+//#define WICED_USE_WIFI_32K_CLOCK_MCO
 
 /*  OTA */
 #define PLATFORM_HAS_OTA
