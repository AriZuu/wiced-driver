diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..1955793
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1 @@
+generated_mac_address.txt
diff --git a/WICED/network/LwIP/WWD/wwd_buffer.c b/WICED/network/LwIP/WWD/wwd_buffer.c
index 4e7f56d..7307646 100644
--- a/WICED/network/LwIP/WWD/wwd_buffer.c
+++ b/WICED/network/LwIP/WWD/wwd_buffer.c
@@ -11,11 +11,11 @@
 #include "network/wwd_buffer_interface.h"
 #include "platform/wwd_bus_interface.h"
 #include "lwip/netbuf.h"
-#include "FreeRTOS.h"
+#include "lwip/pbuf.h"
 #include "lwip/memp.h"
-#include "task.h"
 #include <string.h> /* for NULL */
 #include "wwd_assert.h"
+#include "network/wwd_network_constants.h"
 
 void memp_free_notify( unsigned int type );
 
@@ -29,8 +29,7 @@ wwd_result_t host_buffer_init( /*@null@*/ /*@unused@*/ void * native_arg )
 
 wwd_result_t host_buffer_check_leaked( void )
 {
-    wiced_assert( "pbuf TX pool Buffer leakage", memp_in_use( MEMP_PBUF_POOL_TX ) == 0 );
-    wiced_assert( "pbuf RX pool Buffer leakage", memp_in_use( MEMP_PBUF_POOL_RX ) == 0 );
+    wiced_assert( "pbuf pool Buffer leakage", memp_in_use( MEMP_PBUF_POOL ) == 0 );
     wiced_assert( "pbuf ref/rom Buffer leakage", memp_in_use( MEMP_PBUF ) == 0 );
     return WWD_SUCCESS;
 }
@@ -54,10 +53,10 @@ wwd_result_t host_buffer_get( /*@special@*/ /*@out@*/ wiced_buffer_t* buffer, ww
 
     do
     {
-        *buffer = pbuf_alloc( PBUF_RAW, size, ( direction == WWD_NETWORK_RX ) ? PBUF_POOL_RX : PBUF_POOL_TX );
+        *buffer = pbuf_alloc( PBUF_RAW, size, PBUF_POOL);
     } while ( ( *buffer == NULL ) &&
               ( wait == WICED_TRUE ) &&
-              ( vTaskDelay( (portTickType) 1 ), 1 == 1 ) );
+              ( posTaskSleep( 1 ), 1 == 1 ) );
     if ( *buffer == NULL )
     {
 #if 0
@@ -127,15 +126,3 @@ wwd_result_t host_buffer_set_size( /*@temp@*/ wiced_buffer_t buffer, unsigned sh
          return WWD_SUCCESS;
 }
 
-
-void memp_free_notify( unsigned int type )
-{
-    if ( type == MEMP_PBUF_POOL_TX )
-    {
-        host_platform_bus_buffer_freed( WWD_NETWORK_TX );
-    }
-    else if ( type == MEMP_PBUF_POOL_RX )
-    {
-        host_platform_bus_buffer_freed( WWD_NETWORK_RX );
-    }
-}
diff --git a/WICED/network/LwIP/WWD/wwd_network.c b/WICED/network/LwIP/WWD/wwd_network.c
index 67da1bb..b4d0b42 100644
--- a/WICED/network/LwIP/WWD/wwd_network.c
+++ b/WICED/network/LwIP/WWD/wwd_network.c
@@ -17,7 +17,9 @@
 #include "lwip/debug.h"
 #include "lwip/netif.h"
 #include "lwip/igmp.h"
+#include "lwip/ethip6.h"
 #include "netif/etharp.h"
+#include "lwip/mld6.h"
 
 #include "wwd_network.h"
 #include "wwd_wifi.h"
@@ -28,6 +30,7 @@
 #include "wiced_constants.h"
 #include <stdlib.h>
 
+#include "network/wwd_network_constants.h"
 #ifdef ADD_LWIP_EAPOL_SUPPORT
 #define ETHTYPE_EAPOL    0x888E
 #endif
@@ -110,6 +113,10 @@
 static err_t lwip_igmp_mac_filter( struct netif *netif, ip_addr_t *group, u8_t action );
 #endif
 
+#if LWIP_IPV6 && LWIP_IPV6_MLD
+static err_t lwip_mld_mac_filter(struct netif *netif, const ip6_addr_t *group, u8_t action);
+#endif
+
 /**
  * In this function, the hardware should be initialized.
  * Called from ethernetif_init().
@@ -125,8 +132,14 @@ static void low_level_init( /*@partial@*/ struct netif *netif )
     /* Setup the physical address of this IP instance. */
     if ( wwd_wifi_get_mac_address( (wiced_mac_t*) ( netif->hwaddr ), (wwd_interface_t) (int) netif->state ) != WWD_SUCCESS )
     {
+      /* At least for EMW3165, getting mac address for AP interface fails.
+       * Attempt again with STA interface.
+       */
+      if ( wwd_wifi_get_mac_address( (wiced_mac_t*) ( netif->hwaddr ), WWD_STA_INTERFACE ) != WWD_SUCCESS )
+      {
         WPRINT_NETWORK_DEBUG(("Couldn't get MAC address\n"));
         return;
+      }
     }
 
     /* Set Maximum Transfer Unit */
@@ -136,6 +149,13 @@ static void low_level_init( /*@partial@*/ struct netif *netif )
     netif->flags = (u8_t) ( NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP );
 
     /* Do whatever else is needed to initialize interface. */
+#if LWIP_IPV6 && LWIP_IPV6_MLD
+    netif->mld_mac_filter = lwip_mld_mac_filter;
+    ip6_addr_t ip6_allnodes_ll;
+    ip6_addr_set_allnodes_linklocal(&ip6_allnodes_ll);
+    netif->mld_mac_filter(netif, &ip6_allnodes_ll, MLD6_ADD_MAC_FILTER);
+#endif /* LWIP_IPV6 && LWIP_IPV6_MLD */
+
 #if LWIP_IGMP
     netif->flags |= NETIF_FLAG_IGMP;
     netif_set_igmp_mac_filter(netif, lwip_igmp_mac_filter);
@@ -168,7 +188,17 @@ static err_t low_level_output( struct netif *netif, /*@only@*/ struct pbuf *p )
     {
         /* Take a reference to this packet */
         pbuf_ref( p );
+#if ETH_PAD_SIZE
 
+/*
+ * Wiced layer expects that pbuf points to beginning
+ * of ethernet frame. When using a padding word for
+ * alignment we must drop it (actually the padding word
+ * overlaps with the space used by wiced link headers
+ * but LwIP never actually touches it so this is not a problem.
+ */
+        pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
+#endif
         LWIP_ASSERT( "No chained buffers", ( ( p->next == NULL ) && ( ( p->tot_len == p->len ) ) ) );
         wwd_network_send_ethernet_data( p, (wwd_interface_t) (int) netif->state );
 
@@ -204,6 +234,16 @@ void host_network_process_ethernet_data( /*@only@*/ wiced_buffer_t buffer, wwd_i
         return;
 
     /* points to packet payload, which starts with an Ethernet header */
+#if ETH_PAD_SIZE
+
+/*
+ * LwIP expects that incoming pbuf points to padding word of ethernet header.
+ * The padding word actually has data from Wiced link layer but as it
+ * is not modified by LwIP it is ok for them to overlap.
+ */
+    pbuf_header(buffer, ETH_PAD_SIZE); /* add the padding word */
+#endif
+
     ethernet_header = (struct eth_hdr *) buffer->payload;
 
     ethertype = htons( ethernet_header->type );
@@ -227,6 +267,7 @@ void host_network_process_ethernet_data( /*@only@*/ wiced_buffer_t buffer, wwd_i
     switch ( ethertype )
     {
         case WICED_ETHERTYPE_IPv4:
+        case ETHTYPE_IPV6:
         case WICED_ETHERTYPE_ARP:
 #if PPPOE_SUPPORT
         /* PPPoE packet? */
@@ -325,6 +366,9 @@ err_t ethernetif_init( /*@partial@*/ struct netif *netif )
      */
     netif->output = etharp_output;
     netif->linkoutput = low_level_output;
+#if LWIP_IPV6
+  netif->output_ip6 = ethip6_output;
+#endif
 
     /* Initialize the hardware */
     low_level_init( netif );
@@ -367,4 +411,45 @@ static err_t lwip_igmp_mac_filter( struct netif *netif, ip_addr_t *group, u8_t a
 }
 #endif
 
+#if LWIP_IPV6 && LWIP_IPV6_MLD
+static err_t lwip_mld_mac_filter(struct netif *netif, const ip6_addr_t *group, u8_t action)
+{
+  wiced_mac_t mac;
+  uint8_t* g = (uint8_t*)&group->addr[3];
+
+  mac.octet[0] = 0x33;
+  mac.octet[1] = 0x33;
+  mac.octet[2] = g[0];
+  mac.octet[3] = g[1];
+  mac.octet[4] = g[2];
+  mac.octet[5] = g[3];
+
+  /*@-noeffect@*/
+  UNUSED_PARAMETER(netif);
+  /*@+noeffect@*/
+
+  switch ( action )
+  {
+      case MLD6_ADD_MAC_FILTER:
+          if ( wwd_wifi_register_multicast_address( &mac ) != WWD_SUCCESS )
+          {
+              return ERR_VAL;
+          }
+          break;
+
+      case MLD6_DEL_MAC_FILTER:
+          if ( wwd_wifi_unregister_multicast_address( &mac ) != WWD_SUCCESS )
+          {
+              return ERR_VAL;
+          }
+          break;
+
+      default:
+          return ERR_VAL;
+  }
+
+  return ERR_OK;
+}
+#endif
+
 /********************************** End of file ******************************************/
